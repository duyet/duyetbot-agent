# Agentic Loop Tools

Built-in tools available to agents in the agentic loop. These tools enable agents to perform various actions, gather information, and decompose complex tasks.

## Overview

Tools are callable utilities registered with the `ToolExecutor` that agents can use during reasoning. Each tool:
- Has a unique name and description
- Defines parameter schemas (JSON Schema format)
- Implements an async execute function
- Returns structured results with success/error info

## Available Tools

### Plan Tool

**Purpose**: Break complex tasks into executable steps

**When to use**:
- Multi-step tasks requiring decomposition
- Complex workflows that need organization
- Tasks that benefit from "thinking out loud"
- When agent needs to plan before acting

**Parameters**:
- `task` (required, string): The complex task to decompose
- `context` (optional, string): Additional constraints or requirements

**Example**:
```typescript
const result = await planTool.execute(
  {
    task: 'Implement microservices architecture',
    context: 'Node.js, PostgreSQL, Docker, Kubernetes'
  },
  loopContext
);
```

**Response**:
```
Planning task decomposition:

Task: Implement microservices architecture

Context: Node.js, PostgreSQL, Docker, Kubernetes

Iteration: 1

Now, generate a structured plan by breaking this task into numbered steps...
```

**Design Philosophy**:
The plan tool is a "thinking out loud" mechanism that:
- Validates the task is clear and actionable
- Provides context from previous tool invocations
- Prompts the agent to generate structured steps
- Returns iteration information for tracing

The actual step breakdown is generated by the LLM based on the tool's response, not by the tool itself.

### Memory Tool

**Purpose**: Retrieve personal information about Duyet

**Available information**:
- Blog posts and technical writing
- CV and professional background
- Contact information and social links
- Project highlights

### Research Tool

**Purpose**: Web search and information retrieval

**Search types**:
- General web search
- News and current events
- Technical documentation

**Features**:
- Configurable result count
- Multiple source types
- Formatted result aggregation

### GitHub Tool

**Purpose**: GitHub API operations

**Capabilities**:
- List and search pull requests
- Create and manage issues
- Access repository information
- Trigger workflows

### Subagent Tool

**Purpose**: Delegate independent subtasks to parallel execution

**Use cases**:
- Breaking work into parallel streams
- Distributed task processing
- Multi-threaded problem solving

## Tool Architecture

### LoopTool Interface

```typescript
interface LoopTool {
  name: string;                                          // Unique tool identifier
  description: string;                                   // Human-readable description
  parameters: ToolParameters;                            // JSON Schema format
  execute: (args: Record<string, unknown>,
            ctx: LoopContext) => Promise<ToolResult>;   // Execution function
}
```

### ToolResult Structure

```typescript
interface ToolResult {
  success: boolean;                    // Execution succeeded
  output: string;                      // Primary output for LLM
  data?: unknown;                      // Structured result data
  error?: string;                      // Error message if failed
  durationMs: number;                  // Execution time
}
```

### LoopContext

Available to all tool execute functions:

```typescript
interface LoopContext {
  executionContext: ExecutionContext;  // Platform info, tracing
  iteration: number;                   // Current iteration (0-indexed)
  toolHistory: ToolInvocation[];       // Previous tool invocations
  isSubagent: boolean;                 // Executing as subagent
  parentLoopId?: string;               // Parent loop ID if subagent
}
```

## Registering Tools

### With ToolExecutor

```typescript
import { ToolExecutor } from '../tool-executor.js';
import { planTool, researchTool } from './index.js';

const executor = new ToolExecutor();
executor.register(planTool);
executor.register(researchTool);

// Or register multiple at once
executor.registerAll([planTool, researchTool]);
```

### In Agentic Loop

```typescript
import { AgenticLoop } from '../agentic-loop.js';
import { planTool, researchTool } from './tools/index.js';

const loop = new AgenticLoop({
  maxIterations: 10,
  tools: [planTool, researchTool],
  systemPrompt: 'You are a helpful agent...'
});
```

## Tool Execution Flow

1. **Tool Discovery**: Agent sees available tools in system prompt
2. **Tool Selection**: LLM decides to use a tool (or not)
3. **Argument Generation**: LLM generates tool arguments
4. **Validation**: Arguments validated against schema
5. **Execution**: Tool execute function called with args and context
6. **Result Capture**: Result returned to LLM in message history
7. **Reasoning**: LLM continues with tool results

## Best Practices

### Tool Design

1. **Clear Purpose**: Each tool should have a single, focused purpose
2. **Meaningful Names**: Use descriptive, snake_case names
3. **Good Descriptions**: Help the LLM understand when to use this tool
4. **Proper Validation**: Validate inputs early and clearly
5. **Useful Errors**: Return clear error messages for failure cases

### Tool Usage

1. **Error Recovery**: Tool errors don't crash the loop, fed back to LLM
2. **Parallel Execution**: Multiple tools invoked in one iteration run in parallel
3. **Context Awareness**: Use iteration and tool history from LoopContext
4. **Performance**: Aim for <1s execution for most tools
5. **Logging**: Use logger for debugging and observability

### Parameter Design

1. **Required vs Optional**: Only mark truly required parameters
2. **Clear Descriptions**: Describe what each parameter does
3. **Type Safety**: Use proper JSON Schema types
4. **Examples**: Include example values in descriptions
5. **Constraints**: Document limits (max length, value ranges, etc.)

## Performance Considerations

### Execution Timing

Tools should track and report execution duration:

```typescript
const startTime = Date.now();
try {
  const result = await performWork();
  return {
    success: true,
    output: result,
    durationMs: Date.now() - startTime
  };
} catch (error) {
  return {
    success: false,
    error: error.message,
    durationMs: Date.now() - startTime
  };
}
```

### Optimization

- Cache results when possible
- Batch similar operations
- Use parallel execution for independent tasks
- Monitor slow operations with logger.warn()

## Testing Tools

### Test Structure

```typescript
describe('ToolName', () => {
  let mockContext: LoopContext;

  beforeEach(() => {
    mockContext = createMockLoopContext();
  });

  it('should execute successfully', async () => {
    const result = await toolName.execute(args, mockContext);
    expect(result.success).toBe(true);
  });
});
```

### What to Test

1. Normal operation with valid inputs
2. Edge cases (empty strings, null values, large inputs)
3. Error handling with invalid inputs
4. Parameter validation
5. Context awareness (iterations, history, subagent status)
6. Performance expectations
7. Proper logging

## Future Tools

Planned tools for future implementation:

- **bash**: Shell command execution
- **git**: Git repository operations
- **analyze**: Code analysis and insights
- **memory-mcp**: Cross-session memory via MCP

## Troubleshooting

### Tool Not Found

If you see "Tool '...' not found" error:
1. Verify tool is registered with executor
2. Check tool name is spelled correctly
3. Ensure tool is exported from index.ts

### Tool Fails to Execute

Debug with logger output:
```typescript
logger.debug('[ToolName] Executing...', { args, iteration });
```

Check:
1. Required parameters are present
2. Parameter types match schema
3. External APIs/services are available
4. Proper error handling and error messages

### Performance Issues

Monitor execution time:
```typescript
if (result.durationMs > 1000) {
  logger.warn('[ToolName] Slow execution', {
    durationMs: result.durationMs
  });
}
```

Optimize by:
1. Reducing external API calls
2. Implementing caching
3. Using batch operations
4. Parallel execution where applicable

## References

- [ToolExecutor](../tool-executor.ts)
- [Agentic Loop](../agentic-loop.ts)
- [Types](../types.ts)
- [Agent Architecture](../../../../docs/architecture.md)
