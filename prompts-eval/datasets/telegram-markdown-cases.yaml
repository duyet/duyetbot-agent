# Telegram MarkdownV2 Format Test Cases
# Tests response quality and MarkdownV2 format for Telegram bot
# All tests use outputFormat: telegram-markdown

# =============================================================================
# CONCISENESS TESTS (3 tests)
# =============================================================================

- description: "[Markdown] Concise response - factual question"
  vars:
    outputFormat: "telegram-markdown"
    query: "What is the capital of France?"
  assert:
    - type: llm-rubric
      value: "Response is concise - answers directly with the capital name. Acceptable: 'Paris' or 'Paris, France' or 'The capital is Paris'. Not acceptable: lengthy introductions or explanations."

- description: "[Markdown] Concise response - code snippet"
  vars:
    outputFormat: "telegram-markdown"
    query: "How do I reverse a string in Python?"
  assert:
    - type: llm-rubric
      value: "Response includes code example (using backticks or triple backticks) as primary content. Can have minimal explanation (1-2 sentences max). No lengthy preambles or filler."

- description: "[Markdown] Concise response - explanation"
  vars:
    outputFormat: "telegram-markdown"
    query: "What is Docker?"
  assert:
    - type: llm-rubric
      value: "Response is concise (1-3 sentences max). Explains Docker's purpose clearly without fluff. Acceptable length: ~50-100 words for a brief explanation."

# =============================================================================
# NO FILLER TESTS (2 tests)
# =============================================================================

- description: "[Markdown] No filler - direct answer"
  vars:
    outputFormat: "telegram-markdown"
    query: "What is 15 times 23?"
  assert:
    - type: not-contains
      value: "Sure"
    - type: not-contains
      value: "Great question"
    - type: llm-rubric
      value: "Response starts directly with the answer, no filler phrases"

- description: "[Markdown] No filler - list response"
  vars:
    outputFormat: "telegram-markdown"
    query: "List 3 JavaScript frameworks"
  assert:
    - type: not-contains
      value: "Here are"
    - type: llm-rubric
      value: "Lists items directly without introductory phrases like 'Here are' or 'The frameworks are'"

# =============================================================================
# MARKDOWNV2 FORMAT TESTS (6 tests)
# =============================================================================

- description: "[Markdown] Bold emphasis uses *asterisks*"
  vars:
    outputFormat: "telegram-markdown"
    query: "What is the most important thing to know about Kubernetes?"
  assert:
    - type: javascript
      value: "output.includes('*') && !output.includes('<b>')"
    - type: llm-rubric
      value: "Uses MarkdownV2 *asterisks* for bold emphasis, NOT HTML <b> tags"

- description: "[Markdown] Inline code uses backticks"
  vars:
    outputFormat: "telegram-markdown"
    query: "How do I check git branch?"
  assert:
    - type: contains
      value: "`"
    - type: not-contains
      value: "<code>"
    - type: llm-rubric
      value: "Uses MarkdownV2 backticks for inline code, NOT HTML <code> tags"

- description: "[Markdown] Code block uses triple backticks"
  vars:
    outputFormat: "telegram-markdown"
    query: "Show a Python function to fetch JSON from an API"
  assert:
    - type: contains
      value: "```"
    - type: not-contains
      value: "<pre>"
    - type: llm-rubric
      value: "Uses MarkdownV2 triple backticks for code blocks with language identifier, NOT HTML <pre> tags"

- description: "[Markdown] Links use [text](url) format"
  vars:
    outputFormat: "telegram-markdown"
    query: "Give me a link to the React documentation"
  assert:
    - type: llm-rubric
      value: "Uses MarkdownV2 [text](url) format for links, NOT HTML <a> tags"

- description: "[Markdown] Bold link - markers wrap entire link"
  vars:
    outputFormat: "telegram-markdown"
    query: "Show me how to format a bold link to github.com"
  assert:
    - type: javascript
      value: "!output.includes('[*') && !output.includes('*]')"
    - type: llm-rubric
      value: "Bold markers wrap ENTIRE link: *[text](url)* is CORRECT. [*text*](url) is WRONG."

- description: "[Markdown] No manual escaping of special chars"
  vars:
    outputFormat: "telegram-markdown"
    query: "Write about Node.js version 20.1"
  assert:
    - type: not-contains
      value: "\\."
    - type: not-contains
      value: "\\-"
    - type: llm-rubric
      value: "Should NOT manually escape special characters. Write naturally: 'Node.js 20.1' not 'Node\\.js 20\\.1'"

# =============================================================================
# URL SUMMARIZATION TESTS (4 tests)
# =============================================================================

- description: "[Markdown] URL only - trigger web fetch"
  vars:
    outputFormat: "telegram-markdown"
    query: "https://news.ycombinator.com/item?id=42345678"
  assert:
    - type: javascript
      value: |
        // Check that response indicates action on URL or understanding of content
        const actionPatterns = [
          /web_fetch/i,
          /fetch/i,
          /read/i,
          /access/i,
          /retrieve/i,
          /tool/i,
          /let me/i,
          /I('ll| will| can| need)/i,
          /I'm.*access/i,
          /I'm.*fetch/i,
          /can.*access/i,
          /will.*fetch/i,
        ];
        const understandsContent = [
          /hacker\s*news/i,
          /ycombinator/i,
          /y\s*combinator/i,
          /hackernews/i,
          /tech.*news/i,
          /startup.*news/i,
        ];
        const indicatesAction = actionPatterns.some(p => p.test(output));
        const knowsContent = understandsContent.some(p => p.test(output));
        // Pass if shows action OR understands content (indicating it would fetch)
        const indicatesWillProcess = indicatesAction || knowsContent;
        const asksForClarification = /what would you like|what do you want|how can i help|what.*know about/i.test(output);
        const score = indicatesWillProcess ? (asksForClarification ? 0.5 : 1) : 0.2;
        return {
          pass: score >= 0.5,
          score,
          reason: indicatesAction
            ? (asksForClarification ? 'Preferably act without asking' : 'Correctly indicates action')
            : (knowsContent ? 'Shows understanding of URL content' : 'Should indicate will fetch/access URL')
        };

- description: "[Markdown] URL with comment - summarize with context"
  vars:
    outputFormat: "telegram-markdown"
    query: "Check this out https://github.com/anthropics/claude-code"
  assert:
    - type: javascript
      value: |
        // Check response handles URL appropriately, no filler
        const hasExcessiveFiller = /^(interesting!|cool!|great!|nice!|awesome!|sounds great|sounds cool)/i.test(output.trim());
        const handlesUrl = /fetch|read|access|github|anthropic|claude|code.*tool/i.test(output);
        const understandsContent = /github|anthropic|claude|repository|repo|project/i.test(output);
        const score = (handlesUrl || understandsContent) ? (hasExcessiveFiller ? 0.5 : 1) : 0.3;
        return {
          pass: score >= 0.5,
          score,
          reason: hasExcessiveFiller
            ? 'Avoid excessive filler at start'
            : (handlesUrl || understandsContent ? 'Appropriately handles URL with context' : 'Should address the GitHub URL or project')
        };

- description: "[Markdown] Multiple URLs - summarize each"
  vars:
    outputFormat: "telegram-markdown"
    query: "https://react.dev and https://vuejs.org"
  assert:
    - type: javascript
      value: |
        // Check that response shows understanding of both frameworks
        const mentionsReact = /react|reactjs/i.test(output);
        const mentionsVue = /vue|vuejs/i.test(output);
        const indicatesAction = /fetch|access|read|tool|let me/i.test(output);
        const asksToPickOne = /which (one|url|framework)|pick one|choose one|which would you like/i.test(output);
        let score = 0;
        if (indicatesAction) score = 0.5;  // Says it will fetch
        if (mentionsReact && mentionsVue) score = Math.max(score, 1);  // Knows both
        if (mentionsReact || mentionsVue) score = Math.max(score, 0.6);  // Knows at least one
        if (asksToPickOne && score > 0.5) score -= 0.3;  // Penalty for asking user to pick
        return {
          pass: score >= 0.5,
          score: Math.max(0, score),
          reason: asksToPickOne && score < 0.5
            ? 'Should not ask user to pick which URL - process both'
            : (mentionsReact && mentionsVue ? 'Knows both frameworks' : 'Should address or attempt to access both URLs')
        };

- description: "[Markdown] URL summary format - bullet points"
  vars:
    outputFormat: "telegram-markdown"
    query: "https://blog.cloudflare.com/workers-ai"
  assert:
    - type: javascript
      value: |
        // Check for structured format or action
        const hasBullets = /[â€¢\-\*]\s+\S/.test(output);
        const hasNumbered = /^\d+[\.\)]/m.test(output);
        const indicatesAction = /fetch|access|read|tool|cloudflare|workers|ai|let me/i.test(output);
        const hasMultilineStructure = output.split('\n').filter(l => l.trim()).length >= 3;
        const hasStructure = hasBullets || hasNumbered || hasMultilineStructure;
        const hasVerboseIntro = /^(here('s| is) (what|the)|let me now summarize|i('ll| will) now give)/i.test(output.trim());
        let score = 0;
        if (indicatesAction) score = 0.6;  // Shows it will fetch
        if (hasStructure) score = Math.max(score, 1);  // Structured response
        if (hasVerboseIntro && hasStructure) score -= 0.2;  // Minor penalty for verbose
        return {
          pass: score >= 0.5,
          score: Math.max(0, score),
          reason: indicatesAction
            ? (hasStructure ? 'Good structured format with action indication' : 'Shows will fetch/access content')
            : (hasStructure ? 'Well-structured summary' : 'Consider structured bullet points')
        };

# =============================================================================
# CONVERSATION CONTEXT TESTS (2 tests)
# =============================================================================

- description: "[Markdown] Follow-up question understanding"
  vars:
    outputFormat: "telegram-markdown"
    query: "What about Vue?"
  assert:
    - type: llm-rubric
      value: "Should NOT ask 'What about Vue do you want to know?' Should provide useful info about Vue assuming prior context."

- description: "[Markdown] Progressive disclosure"
  vars:
    outputFormat: "telegram-markdown"
    query: "Explain microservices architecture"
  assert:
    - type: javascript
      value: |
        // Check for concise response (not a wall of text)
        const lines = output.trim().split('\n').filter(l => l.trim());
        const wordCount = output.split(/\s+/).length;
        const isConcise = wordCount < 200;  // Under 200 words is reasonable
        const hasOffer = /want.*more|ask.*detail|expand|more info/i.test(output);
        let score = isConcise ? 0.7 : 0.3;
        if (hasOffer) score += 0.3;
        return {
          pass: score >= 0.5,
          score: Math.min(1, score),
          reason: isConcise
            ? (hasOffer ? 'Concise with offer to expand' : 'Concise response')
            : 'Response too verbose for mobile'
        };

# =============================================================================
# MOBILE OPTIMIZATION TESTS (2 tests)
# =============================================================================

- description: "[Markdown] Short line length for mobile"
  vars:
    outputFormat: "telegram-markdown"
    query: "What are the SOLID principles?"
  assert:
    - type: llm-rubric
      value: "Response should be mobile-friendly with short paragraphs. Uses bullet points for the 5 principles."

- description: "[Markdown] No nested bullets"
  vars:
    outputFormat: "telegram-markdown"
    query: "List programming paradigms with examples"
  assert:
    - type: llm-rubric
      value: "Should NOT use nested bullet points (hard to read on mobile). Flat list or categories instead."

# =============================================================================
# EDGE CASES (2 tests)
# =============================================================================

- description: "[Markdown] Empty or unclear query"
  vars:
    outputFormat: "telegram-markdown"
    query: "?"
  assert:
    - type: llm-rubric
      value: "Should ask for clarification briefly. Should NOT give a long explanation about what it can do."

- description: "[Markdown] Emoji handling"
  vars:
    outputFormat: "telegram-markdown"
    query: "How do I feel about TypeScript?"
  assert:
    - type: llm-rubric
      value: "Response can use emojis sparingly but should stay professional and concise."

# =============================================================================
# MARKDOWNV2-SPECIFIC TESTS (4 tests)
# =============================================================================

- description: "[Markdown] Italic link - markers wrap entire link"
  vars:
    outputFormat: "telegram-markdown"
    query: "Format an italic link to vuejs.org documentation"
  assert:
    - type: javascript
      value: "!output.includes('[_') && !output.includes('_]')"
    - type: llm-rubric
      value: "Italic markers wrap ENTIRE link: _[text](url)_ is CORRECT. [_text_](url) is WRONG."

- description: "[Markdown] No HTML tags at all"
  vars:
    outputFormat: "telegram-markdown"
    query: "Explain the difference between let and const in JavaScript"
  assert:
    - type: not-contains
      value: "<b>"
    - type: not-contains
      value: "<i>"
    - type: not-contains
      value: "<code>"
    - type: not-contains
      value: "<pre>"
    - type: llm-rubric
      value: "Uses MarkdownV2 formatting only (*bold*, _italic_, `code`), NO HTML tags"

- description: "[Markdown] Underline uses double underscore"
  vars:
    outputFormat: "telegram-markdown"
    query: "Show how to underline text in Telegram"
  assert:
    - type: llm-rubric
      value: "Uses MarkdownV2 __double underscores__ for underline text"

- description: "[Markdown] Spoiler uses double pipes"
  vars:
    outputFormat: "telegram-markdown"
    query: "Show how to create a spoiler in Telegram"
  assert:
    - type: llm-rubric
      value: "Uses MarkdownV2 ||double pipes|| for spoiler/hidden text"

# =============================================================================
# CREATOR INFO TESTS (2 tests)
# =============================================================================

- description: "[Markdown] Creator CV request"
  vars:
    outputFormat: "telegram-markdown"
    query: "What is Duyet's CV?"
  assert:
    - type: javascript
      value: |
        // Check that response indicates using creator_info tool or accesses real data
        const toolPatterns = [
          /creator_info/i,
          /fetch.*duyet/i,
          /get.*duyet.*info/i,
          /mcp.*creator/i,
          /tool.*creator/i,
          /let me.*fetch/i,
          /let me.*check/i,
          /I.*can access/i,
          /I.*need to.*access/i,
          /accessing.*information/i,
          /retrieve.*profile/i,
        ];
        const indicatesTool = toolPatterns.some(p => p.test(output));
        // Only fail if explicitly making up info without any tool mention
        const makesUpWithoutTool = /(?:duyet is a|duyet works|duyet has|duyet is).*(?:engineer|developer|manager|architect)/i.test(output)
          && !toolPatterns.some(p => p.test(output));
        return {
          pass: !makesUpWithoutTool,
          score: indicatesTool ? 1 : (makesUpWithoutTool ? 0 : 0.6),
          reason: indicatesTool
            ? 'Correctly indicates using tool or accessing real data'
            : (makesUpWithoutTool ? 'Should NOT make up CV details without indicating tool use' : 'Responds appropriately to CV request')
        };

- description: "[Markdown] Creator info request"
  vars:
    outputFormat: "telegram-markdown"
    query: "Who is Duyet?"
  assert:
    - type: javascript
      value: |
        // Check that response indicates using creator_info tool or accesses real data
        const toolPatterns = [
          /creator_info/i,
          /fetch.*duyet/i,
          /get.*duyet.*info/i,
          /mcp.*creator/i,
          /tool.*creator/i,
          /let me.*fetch/i,
          /let me.*check/i,
          /I.*can access/i,
          /I.*need to.*access/i,
          /accessing.*information/i,
          /look.*up/i,
        ];
        const indicatesTool = toolPatterns.some(p => p.test(output));
        // Only fail if fabricating specific personal facts without tool mention
        const fabricatesWithoutTool = /(?:duyet is|duyet was|duyet lives|duyet works at|duyet is from).*(?:\w+)/i.test(output)
          && !toolPatterns.some(p => p.test(output))
          && !/duyet is an?.*(?:ai|agent|bot|assistant)/i.test(output);
        return {
          pass: !fabricatesWithoutTool,
          score: indicatesTool ? 1 : (fabricatesWithoutTool ? 0 : 0.6),
          reason: indicatesTool
            ? 'Correctly indicates using tool or accessing real data'
            : (fabricatesWithoutTool ? 'Should NOT fabricate personal details without indicating tool use' : 'Responds appropriately to personal info request')
        };
